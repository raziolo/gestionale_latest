{% extends "frontend/base_cms/base.html" %}
{% load static %}
{% load custom_filters %}

{% block content %}
<div class="min-h-screen bg-base-200 p-6">
  <h1 class="text-3xl font-bold mb-6">Enhanced Schedule DataTable</h1>

  <div class="overflow-x-auto">
    <table class="table table-zebra w-full border-collapse">
      <thead>
        <tr>
          <th rowspan="2" class="bg-base-300 sticky left-0 z-10">
            Employee
          </th>
          {% for day in sorted_days %}
            <th class="bg-base-300 text-center"
                colspan="{{ day_times_map|get_item:day|length }}">
              {{ day }}
            </th>
          {% endfor %}
        </tr>
        <tr>
          {% for day in sorted_days %}
            {% for time_key in day_times_map|get_item:day %}
              <th class="bg-base-200 text-xs text-center {% if forloop.last %}day-separator{% endif %}">
                {{ time_key|time_display }}
              </th>
            {% endfor %}
          {% endfor %}
        </tr>
      </thead>
      <tbody>
        {% for e in employees %}
          <tr>
            <td class="sticky left-0 bg-base-300 z-10 font-semibold">
              {{ e.name }}
            </td>
            {% for day in sorted_days %}
              {% for time_key in day_times_map|get_item:day %}
                {% with assigned_list=schedule_data|get_item:day|get_item:time_key %}
                  {% if e.id|stringformat:"s" in assigned_list %}
                    <td class="assignedCell text-center hover:bg-base-100 hover:cursor-pointer border border-base-200 {% if forloop.last %}day-separator{% endif %}"
                        data-day="{{ day }}"
                        data-time="{{ time_key }}"
                        data-employee-id="{{ e.id }}">
                      X
                    </td>
                  {% else %}
                    <td class="text-center hover:bg-base-100 hover:cursor-pointer border border-base-200 {% if forloop.last %}day-separator{% endif %}"
                        data-day="{{ day }}"
                        data-time="{{ time_key }}"
                        data-employee-id="{{ e.id }}">
                      &nbsp;
                    </td>
                  {% endif %}
                {% endwith %}
              {% endfor %}
            {% endfor %}
          </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

</div>

    <div class="card w-100 bg-base-300 shadow-xl p-6 m-5">
        <div id="workedHoursTotal" class="my-6"></div>
    </div>

<style>
  .assignedCell {
    background-color: rgb(251 191 36 / 0.2); /* a mild highlight (Tailwind amber-300, ~20% alpha) */
    position: relative;
  }
  .assignedCell[data-day] + .assignedCell[data-day]:not(:first-child) {
    border-left: none;
  }

  /* Example "preview" style (when dragging over cells) */
  .drag-select {
    outline: 2px solid #fbbf24; /* Tailwind amber-300, for demonstration */
  }
</style>

<script>
document.addEventListener("DOMContentLoaded", function() {
  const scheduleId = "{{ schedule.id }}";
  const table = document.querySelector("table");

  let isDragging = false;
  // Will store references like:
  //   cellMap.set(cell, { day, timeStr, employeeId, finalAssigned: true/false });
  const cellMap = new Map();

  // MOUSE DOWN
  table.addEventListener("mousedown", function(e) {
    const cell = e.target.closest("td[data-day]");
    if (!cell) return;

    isDragging = true;

    // Clear all previous toggles for a fresh drag
    cellMap.clear();

    // Toggle the starting cell immediately
    toggleCell(cell);
    e.preventDefault(); // Prevent text selection or other default drags
  });

  // MOUSE OVER
  table.addEventListener("mouseover", function(e) {
    if (!isDragging) return;
    const cell = e.target.closest("td[data-day]");
    if (!cell) return;

    // If we haven't toggled this cell yet, toggle it now
    // (If you do want "crossing back" to re-toggle, remove the "hasn't toggled yet" check)
    if (!cellMap.has(cell)) {
      toggleCell(cell);
    }
  });

  // MOUSE UP
  document.addEventListener("mouseup", function(e) {
    if (!isDragging) return;
    isDragging = false;

    // Build bulk payload from cellMap
    const togglesPayload = [];
    for (const [cell, info] of cellMap.entries()) {
      togglesPayload.push({
        day: info.day,
        time_str: info.timeStr,
        employee_id: parseInt(info.employeeId),
        assign: info.finalAssigned // true => assign, false => unassign
      });
    }

    if (!togglesPayload.length) return;

    fetch("{% url 'toggle_assignment_bulk' %}", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie('csrftoken')
      },
      body: JSON.stringify({
        schedule_id: scheduleId,
        toggles: togglesPayload
      })
    })
    .then(resp => resp.json())
    .then(data => {
      if (!data.success) {
        console.warn("Bulk toggle failed:", data.message);
      }
      // Either way, weâ€™ve already updated the DOM in real time
      // If you want to revert on error, you'd do that here
    })
    .catch(err => {
      console.error("Bulk toggle error:", err);
    });
  });

  function toggleCell(cell) {
    const day = cell.dataset.day;
    const timeStr = cell.dataset.time.trim();
    const employeeId = cell.dataset.employeeId;

    // Check current text to see if assigned
    const currentlyAssigned = (cell.innerText.trim() === "X");
    const newAssigned = !currentlyAssigned; // flip

    // Update the DOM immediately
    if (newAssigned) {
      cell.innerText = "X";
      cell.classList.add("assignedCell");
    } else {
      cell.innerHTML = "&nbsp;";
      cell.classList.remove("assignedCell");
    }

    // Store the final state in our map
    cellMap.set(cell, {
      day,
      timeStr,
      employeeId,
      finalAssigned: newAssigned
    });
  }

  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== "") {
      const cookies = document.cookie.split(";");
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + "=")) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});

/**
   * Render the total worked hours table for each employee
   * Example data shape:
   * {
   *   "2025-02-01": {"1": 4.0, "2": 0, "3": 2.5},
   *   "2025-02-02": {"1": 5.0, "2": 6.0, "3": 1.5}
   * }
   */
  function renderTotalWorkedHours(pivotData) {
    try {
      const totalWorkedHours = {};

      // Aggregate total worked hours for each employee
      Object.keys(pivotData).forEach(day => {
        const dayObj = pivotData[day];
        for (let empId in dayObj) {
          totalWorkedHours[empId] = (totalWorkedHours[empId] || 0) + dayObj[empId];
        }
      });

      // Build the total hours table
      let html = `
        <div class="overflow-auto">
          <table class="table table-zebra w-full">
            <thead>
              <tr>
                <th>Employee ID</th>
                <th>Total Worked Hours</th>
              </tr>
            </thead>
            <tbody>
      `;

      for (let empId in totalWorkedHours) {
        html += `
          <tr>
            <td>${empId}</td>
            <td>${totalWorkedHours[empId].toFixed(2)}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>
      `;

      document.getElementById("workedHoursTotal").innerHTML = html;
    } catch (error) {
      console.error("Error rendering total worked hours:", error);
      Swal.fire("Error", "An error occurred while rendering the total worked hours: " + error.message, "error");
    }
  }


</script>

    <style>

    table {
  border-collapse: collapse; /* Ensure borders are merged */
}

table th,
table td {
  border: 1px solid rgba(0, 0, 0, 0.1); /* A very subtle border */
}
  .assignedCell {
    background-color: var(--assigned-cell-color); /* a mild highlight */
    position: relative;
      border:none;

  }
  .assignedCell[data-day] + .assignedCell[data-day]:not(:first-child) {
      border: none;
  }

  /* Separator style for the last cell of each day group */
  .day-separator {
    border-right: 2px solid #000; /* Change color and width as desired */
  }
</style>
{% endblock content %}
