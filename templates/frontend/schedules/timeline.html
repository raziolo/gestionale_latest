{% extends "frontend/base_cms/base.html" %}
{% load static %}
{% load custom_filters %}

{% block content %}
<div class="min-h-screen bg-base-200 p-6">
  <h1 class="text-3xl font-bold mb-6">Enhanced Schedule DataTable</h1>

  <!-- Debug: Show raw JSON if you like -->
  {# <pre class="mb-4">{{ schedule_data|safe }}</pre> #}

  <div class="overflow-x-auto">
    <table class="table table-compact w-full border-collapse">
      <thead>
        <!-- First Header Row: Days with colSpan -->
        <tr>
          <!-- Sticky left corner for "Employee" label -->
          <th rowspan="2" class="bg-base-300 sticky left-0 z-10">
            Employee
          </th>
          {% for day in sorted_days %}
            <th class="bg-base-300 text-center"
                colspan="{{ day_times_map|get_item:day|length }}">
              {{ day }}
            </th>
          {% endfor %}
        </tr>
        <!-- Second Header Row: each half-hour for each day -->
        <tr>
          {% for day in sorted_days %}
            {% for time_key in day_times_map|get_item:day %}
              <th class="bg-base-200 text-xs text-center">
                {{ time_key|time_display }}
              </th>
            {% endfor %}
          {% endfor %}
        </tr>
      </thead>
      <tbody>
        <!-- One row per employee -->
        {% for e in employees %}
          <tr>
            <!-- Sticky left column for employee name -->
            <td class="sticky left-0 bg-base-300 z-10 font-semibold">
              {{ e.name }}
            </td>
            <!-- Columns: each day/time in the flattened list (or nested loops) -->
            {% for day in sorted_days %}
              {% for time_key in day_times_map|get_item:day %}
                {% with assigned_list=schedule_data|get_item:day|get_item:time_key %}
                  <!-- Check if e.id is in that half-hour's list -->
                  {% if e.id|stringformat:"s" in assigned_list %}
                    <td class="assignedCell text-center hover:bg-base-100 hover:cursor-pointer border border-base-200"
                        data-day="{{ day }}">
                      X
                    </td>
                  {% else %}
                    <td class="text-center hover:bg-base-100 hover:cursor-pointer border border-base-200"
                        data-day="{{ day }}">
                      &nbsp;
                    </td>
                  {% endif %}
                {% endwith %}
              {% endfor %}
            {% endfor %}
          </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>

<!-- Custom CSS for consecutive X's:
     1) .assignedCell => distinct background or highlight
     2) If two adjacent cells in the same row/day are assigned,
        remove the left border on the latter to make them look merged.
-->
<style>
  .assignedCell {
    background-color: rgb(251 191 36 / 0.2); /* a mild highlight (Tailwind amber-300, ~20% alpha) */
    position: relative;
  }
  /* If the previous cell is also assigned and has the same data-day,
     remove the left border from the current cell to visually merge them. */
  .assignedCell[data-day] + .assignedCell[data-day]:not(:first-child) {
    border-left: none;
  }
  /* But we only want to remove the border if the day is the same,
     and they are in the same row (same employee).
     We can refine it by matching the parent's row or data-employee.
     For a pure CSS approach, it's a bit tricky. We'll do a simpler approach:

     We'll rely on :nth-child adjacency in the same row, but also check data-day in the sibling.
     The above rule does that: .assignedCell + .assignedCell
     means two consecutive <td> siblings. If they're assignedCell, we remove the border.

     This merges the blocks horizontally. */

  /* Optional: If you want a subtle leftmost border for the block,
     keep the left border for the first assigned cell in a run:
     For that, we do not remove border-left from the very first assignedCell in the row (the previous cell might not be assigned). */

  /* If you want stronger borders around the entire block, you could add
     .assignedCell:first-of-type or add an outline, etc. */
</style>

<!-- We'll add a small script for toggling on click -->
<script>
document.addEventListener("DOMContentLoaded", function() {
  const scheduleId = "{{ schedule.id }}"; // We pass schedule.id from context
  const table = document.querySelector("table");

  table.addEventListener("click", function(e) {
    // Only act if the clicked element is a cell in the table body
    const cell = e.target.closest("td[data-day]");
    if (!cell) return;

    const day = cell.dataset.day;
    const timeStr = cell.dataset.time;
    const employeeId = cell.dataset.employeeId;

    // Determine the current text: "X" or blank
    const currentText = cell.innerText.trim();
    const isAssigned = currentText === "X";

    // Prepare the toggle data
    const payload = {
      schedule_id: scheduleId,
      day: day,
      time_str: timeStr,
      employee_id: parseInt(employeeId)
    };

    // AJAX call to toggle
    fetch("{% url 'all_schedules' %}", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie('csrftoken') // or your approach for CSRF
      },
      body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        if (data.assigned) {
          cell.innerText = "X";
        } else {
          cell.innerHTML = "&nbsp;";
        }
      } else {
        console.warn("Toggle error:", data.message);
      }
    })
    .catch(error => {
      console.error("Request failed:", error);
    });
  });

  // Helper to get CSRF token from cookies
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== "") {
      const cookies = document.cookie.split(";");
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        // Does this cookie string begin with the name we want?
        if (cookie.substring(0, name.length + 1) === (name + "=")) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});
</script>
{% endblock content %}
